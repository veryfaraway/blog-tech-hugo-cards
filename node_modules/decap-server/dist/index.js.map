{"version":3,"file":"index.js","mappings":"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","sources":["webpack://decap-server/../decap-cms-lib-util/src/APIUtils.ts","webpack://decap-server/./src/index.ts","webpack://decap-server/./src/logger.ts","webpack://decap-server/./src/middlewares/common/index.ts","webpack://decap-server/./src/middlewares/joi/customValidators.ts","webpack://decap-server/./src/middlewares/joi/index.ts","webpack://decap-server/./src/middlewares/localFs/index.ts","webpack://decap-server/./src/middlewares/localGit/index.ts","webpack://decap-server/./src/middlewares/utils/entries.ts","webpack://decap-server/./src/middlewares/utils/fs.ts","webpack://decap-server/external commonjs \"@hapi/joi\"","webpack://decap-server/external commonjs \"async-mutex\"","webpack://decap-server/external commonjs \"cors\"","webpack://decap-server/external commonjs \"dotenv\"","webpack://decap-server/external commonjs \"express\"","webpack://decap-server/external commonjs \"morgan\"","webpack://decap-server/external commonjs \"simple-git\"","webpack://decap-server/external commonjs \"what-the-diff\"","webpack://decap-server/external commonjs \"winston\"","webpack://decap-server/external node-commonjs \"crypto\"","webpack://decap-server/external node-commonjs \"fs\"","webpack://decap-server/external node-commonjs \"path\"","webpack://decap-server/webpack/bootstrap","webpack://decap-server/webpack/startup"],"sourcesContent":["export const CMS_BRANCH_PREFIX = 'cms';\nexport const DEFAULT_PR_BODY = 'Automatically generated by Decap CMS';\nexport const MERGE_COMMIT_MESSAGE = 'Automatically generated. Merged on Decap CMS.';\n\nconst DEFAULT_DECAP_CMS_LABEL_PREFIX = 'decap-cms/';\n\nfunction getLabelPrefix(labelPrefix: string) {\n  return labelPrefix || DEFAULT_DECAP_CMS_LABEL_PREFIX;\n}\n\nexport function isCMSLabel(label: string, labelPrefix: string) {\n  return label.startsWith(getLabelPrefix(labelPrefix));\n}\n\nexport function labelToStatus(label: string, labelPrefix: string) {\n  return label.slice(getLabelPrefix(labelPrefix).length);\n}\n\nexport function statusToLabel(status: string, labelPrefix: string) {\n  return `${getLabelPrefix(labelPrefix)}${status}`;\n}\n\nexport function generateContentKey(collectionName: string, slug: string) {\n  return `${collectionName}/${slug}`;\n}\n\nexport function parseContentKey(contentKey: string) {\n  const index = contentKey.indexOf('/');\n  return { collection: contentKey.slice(0, index), slug: contentKey.slice(index + 1) };\n}\n\nexport function contentKeyFromBranch(branch: string) {\n  return branch.slice(`${CMS_BRANCH_PREFIX}/`.length);\n}\n\nexport function branchFromContentKey(contentKey: string) {\n  return `${CMS_BRANCH_PREFIX}/${contentKey}`;\n}\n","// eslint-disable-next-line @typescript-eslint/no-var-requires\nrequire('dotenv').config();\nimport express from 'express';\n\nimport { registerCommonMiddlewares } from './middlewares/common';\nimport { registerMiddleware as registerLocalGit } from './middlewares/localGit';\nimport { registerMiddleware as registerLocalFs } from './middlewares/localFs';\nimport { createLogger } from './logger';\n\nconst app = express();\nconst port = process.env.PORT || 8081;\nconst level = process.env.LOG_LEVEL || 'info';\n\n(async () => {\n  const logger = createLogger({ level });\n  const options = {\n    logger,\n  };\n\n  registerCommonMiddlewares(app, options);\n\n  try {\n    const mode = process.env.MODE || 'fs';\n    if (mode === 'fs') {\n      registerLocalFs(app, options);\n    } else if (mode === 'git') {\n      registerLocalGit(app, options);\n    } else {\n      throw new Error(`Unknown proxy mode '${mode}'`);\n    }\n  } catch (e) {\n    logger.error(e instanceof Error ? e.message : 'Unknown error');\n    process.exit(1);\n  }\n\n  return app.listen(port, () => {\n    logger.info(`Decap CMS Proxy Server listening on port ${port}`);\n  });\n})();\n","import winston from 'winston';\n\nconst { combine, colorize, simple } = winston.format;\n\ntype LogOptions = {\n  level: string;\n};\n\nexport function createLogger({ level }: LogOptions) {\n  return winston.createLogger({\n    level,\n    format: combine(colorize(), simple()),\n    transports: [new winston.transports.Console()],\n  });\n}\n","import express from 'express';\nimport morgan from 'morgan';\nimport cors from 'cors';\n\nimport type winston from 'winston';\n\nexport type Options = {\n  logger: winston.Logger;\n};\n\nexport function registerCommonMiddlewares(app: express.Express, options: Options) {\n  const { logger } = options;\n  const stream = {\n    write: (message: string) => {\n      logger.debug(String(message).trim());\n    },\n  };\n  app.use(morgan('combined', { stream }));\n  app.use(cors());\n  app.use(express.json({ limit: '50mb' }));\n}\n","import Joi from '@hapi/joi';\nimport path from 'path';\n\nexport function pathTraversal(repoPath: string) {\n  return Joi.extend({\n    type: 'path',\n    base: Joi.string().required(),\n    messages: {\n      'path.invalid': '{{#label}} must resolve to a path under the configured repository',\n    },\n    validate(value, helpers) {\n      const resolvedPath = path.join(repoPath, value);\n      if (!resolvedPath.startsWith(repoPath)) {\n        return { value, errors: helpers.error('path.invalid') };\n      }\n    },\n  }).path();\n}\n","import Joi from '@hapi/joi';\n\nimport type express from 'express';\n\nconst allowedActions = [\n  'info',\n  'entriesByFolder',\n  'entriesByFiles',\n  'getEntry',\n  'unpublishedEntries',\n  'unpublishedEntry',\n  'unpublishedEntryDataFile',\n  'unpublishedEntryMediaFile',\n  'deleteUnpublishedEntry',\n  'persistEntry',\n  'updateUnpublishedEntryStatus',\n  'publishUnpublishedEntry',\n  'getMedia',\n  'getMediaFile',\n  'persistMedia',\n  'deleteFile',\n  'deleteFiles',\n  'getDeployPreview',\n];\n\nconst requiredString = Joi.string().required();\nconst requiredNumber = Joi.number().required();\nconst requiredBool = Joi.bool().required();\n\nconst collection = requiredString;\nconst slug = requiredString;\n\nexport function defaultSchema({ path = requiredString } = {}) {\n  const defaultParams = Joi.object({\n    branch: requiredString,\n  });\n\n  const asset = Joi.object({\n    path,\n    content: requiredString,\n    encoding: requiredString.valid('base64'),\n  });\n\n  const dataFile = Joi.object({\n    slug: requiredString,\n    path,\n    raw: requiredString,\n    newPath: path.optional(),\n  });\n\n  const params = Joi.when('action', {\n    switch: [\n      {\n        is: 'info',\n        then: Joi.allow(),\n      },\n      {\n        is: 'entriesByFolder',\n        then: defaultParams\n          .keys({\n            folder: path,\n            extension: requiredString,\n            depth: requiredNumber,\n          })\n          .required(),\n      },\n      {\n        is: 'entriesByFiles',\n        then: defaultParams.keys({\n          files: Joi.array()\n            .items(Joi.object({ path, label: Joi.string() }))\n            .required(),\n        }),\n      },\n      {\n        is: 'getEntry',\n        then: defaultParams\n          .keys({\n            path,\n          })\n          .required(),\n      },\n      {\n        is: 'unpublishedEntries',\n        then: defaultParams.keys({ branch: requiredString }).required(),\n      },\n      {\n        is: 'unpublishedEntry',\n        then: defaultParams\n          .keys({\n            id: Joi.string().optional(),\n            collection: Joi.string().optional(),\n            slug: Joi.string().optional(),\n            cmsLabelPrefix: Joi.string().optional(),\n          })\n          .required(),\n      },\n      {\n        is: 'unpublishedEntryDataFile',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n            id: requiredString,\n            path: requiredString,\n          })\n          .required(),\n      },\n      {\n        is: 'unpublishedEntryMediaFile',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n            id: requiredString,\n            path: requiredString,\n          })\n          .required(),\n      },\n      {\n        is: 'deleteUnpublishedEntry',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n          })\n          .required(),\n      },\n      {\n        is: 'persistEntry',\n        then: defaultParams\n          .keys({\n            cmsLabelPrefix: Joi.string().optional(),\n            entry: dataFile, // entry is kept for backwards compatibility\n            dataFiles: Joi.array().items(dataFile),\n            assets: Joi.array().items(asset).required(),\n            options: Joi.object({\n              collectionName: Joi.string(),\n              commitMessage: requiredString,\n              useWorkflow: requiredBool,\n              status: requiredString,\n            }).required(),\n          })\n          .xor('entry', 'dataFiles')\n          .required(),\n      },\n      {\n        is: 'updateUnpublishedEntryStatus',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n            newStatus: requiredString,\n            cmsLabelPrefix: Joi.string().optional(),\n          })\n          .required(),\n      },\n      {\n        is: 'publishUnpublishedEntry',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n          })\n          .required(),\n      },\n      {\n        is: 'getMedia',\n        then: defaultParams\n          .keys({\n            mediaFolder: path,\n          })\n          .required(),\n      },\n      {\n        is: 'getMediaFile',\n        then: defaultParams\n          .keys({\n            path,\n          })\n          .required(),\n      },\n      {\n        is: 'persistMedia',\n        then: defaultParams\n          .keys({\n            asset: asset.required(),\n            options: Joi.object({\n              commitMessage: requiredString,\n            }).required(),\n          })\n          .required(),\n      },\n      {\n        is: 'deleteFile',\n        then: defaultParams\n          .keys({\n            path,\n            options: Joi.object({\n              commitMessage: requiredString,\n            }).required(),\n          })\n          .required(),\n      },\n      {\n        is: 'deleteFiles',\n        then: defaultParams\n          .keys({\n            paths: Joi.array().items(path).min(1).required(),\n            options: Joi.object({\n              commitMessage: requiredString,\n            }).required(),\n          })\n          .required(),\n      },\n      {\n        is: 'getDeployPreview',\n        then: defaultParams\n          .keys({\n            collection,\n            slug,\n          })\n          .required(),\n      },\n    ],\n    otherwise: Joi.forbidden(),\n  });\n\n  return Joi.object({\n    action: Joi.valid(...allowedActions).required(),\n    params,\n  });\n}\n\nexport function joi(schema: Joi.Schema) {\n  return (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    const { error } = schema.validate(req.body, { allowUnknown: true });\n    if (error) {\n      const { details } = error;\n      const message = details.map(i => i.message).join(',');\n      res.status(422).json({ error: message });\n    } else {\n      next();\n    }\n  };\n}\n","import path from 'path';\n\nimport { defaultSchema, joi } from '../joi';\nimport { pathTraversal } from '../joi/customValidators';\nimport { listRepoFiles, deleteFile, writeFile, move } from '../utils/fs';\nimport { entriesFromFiles, readMediaFile } from '../utils/entries';\n\nimport type {\n  EntriesByFolderParams,\n  EntriesByFilesParams,\n  GetEntryParams,\n  PersistEntryParams,\n  GetMediaParams,\n  GetMediaFileParams,\n  PersistMediaParams,\n  DeleteFileParams,\n  DeleteFilesParams,\n  DataFile,\n} from '../types';\nimport type express from 'express';\nimport type winston from 'winston';\n\ntype FsOptions = {\n  repoPath: string;\n  logger: winston.Logger;\n};\n\nexport function localFsMiddleware({ repoPath, logger }: FsOptions) {\n  return async function (req: express.Request, res: express.Response) {\n    try {\n      const { body } = req;\n\n      switch (body.action) {\n        case 'info': {\n          res.json({\n            repo: path.basename(repoPath),\n            publish_modes: ['simple'],\n            type: 'local_fs',\n          });\n          break;\n        }\n        case 'entriesByFolder': {\n          const payload = body.params as EntriesByFolderParams;\n          const { folder, extension, depth } = payload;\n          const entries = await listRepoFiles(repoPath, folder, extension, depth).then(files =>\n            entriesFromFiles(\n              repoPath,\n              files.map(file => ({ path: file })),\n            ),\n          );\n          res.json(entries);\n          break;\n        }\n        case 'entriesByFiles': {\n          const payload = body.params as EntriesByFilesParams;\n          const entries = await entriesFromFiles(repoPath, payload.files);\n          res.json(entries);\n          break;\n        }\n        case 'getEntry': {\n          const payload = body.params as GetEntryParams;\n          const [entry] = await entriesFromFiles(repoPath, [{ path: payload.path }]);\n          res.json(entry);\n          break;\n        }\n        case 'persistEntry': {\n          const {\n            entry,\n            dataFiles = [entry as DataFile],\n            assets,\n          } = body.params as PersistEntryParams;\n          await Promise.all(\n            dataFiles.map(dataFile => writeFile(path.join(repoPath, dataFile.path), dataFile.raw)),\n          );\n          // save assets\n          await Promise.all(\n            assets.map(a =>\n              writeFile(path.join(repoPath, a.path), Buffer.from(a.content, a.encoding)),\n            ),\n          );\n          if (dataFiles.every(dataFile => dataFile.newPath)) {\n            dataFiles.forEach(async dataFile => {\n              await move(\n                path.join(repoPath, dataFile.path),\n                path.join(repoPath, dataFile.newPath!),\n              );\n            });\n          }\n          res.json({ message: 'entry persisted' });\n          break;\n        }\n        case 'getMedia': {\n          const { mediaFolder } = body.params as GetMediaParams;\n          const files = await listRepoFiles(repoPath, mediaFolder, '', 1);\n          const mediaFiles = await Promise.all(files.map(file => readMediaFile(repoPath, file)));\n          res.json(mediaFiles);\n          break;\n        }\n        case 'getMediaFile': {\n          const { path } = body.params as GetMediaFileParams;\n          const mediaFile = await readMediaFile(repoPath, path);\n          res.json(mediaFile);\n          break;\n        }\n        case 'persistMedia': {\n          const { asset } = body.params as PersistMediaParams;\n          await writeFile(\n            path.join(repoPath, asset.path),\n            Buffer.from(asset.content, asset.encoding),\n          );\n          const file = await readMediaFile(repoPath, asset.path);\n          res.json(file);\n          break;\n        }\n        case 'deleteFile': {\n          const { path: filePath } = body.params as DeleteFileParams;\n          await deleteFile(repoPath, filePath);\n          res.json({ message: `deleted file ${filePath}` });\n          break;\n        }\n        case 'deleteFiles': {\n          const { paths } = body.params as DeleteFilesParams;\n          await Promise.all(paths.map(filePath => deleteFile(repoPath, filePath)));\n          res.json({ message: `deleted files ${paths.join(', ')}` });\n          break;\n        }\n        case 'getDeployPreview': {\n          res.json(null);\n          break;\n        }\n        default: {\n          const message = `Unknown action ${body.action}`;\n          res.status(422).json({ error: message });\n          break;\n        }\n      }\n    } catch (e) {\n      logger.error(\n        `Error handling ${JSON.stringify(req.body)}: ${\n          e instanceof Error ? e.message : 'Unknown error'\n        }`,\n      );\n      res.status(500).json({ error: 'Unknown error' });\n    }\n  };\n}\n\nexport function getSchema({ repoPath }: { repoPath: string }) {\n  const schema = defaultSchema({ path: pathTraversal(repoPath) });\n  return schema;\n}\n\ntype Options = {\n  logger: winston.Logger;\n};\n\nexport async function registerMiddleware(app: express.Express, options: Options) {\n  const { logger } = options;\n  const repoPath = path.resolve(process.env.GIT_REPO_DIRECTORY || process.cwd());\n  app.post('/api/v1', joi(getSchema({ repoPath })));\n  app.post('/api/v1', localFsMiddleware({ repoPath, logger }));\n  logger.info(`Decap CMS File System Proxy Server configured with ${repoPath}`);\n}\n","import path from 'path';\nimport { promises as fs } from 'fs';\nimport {\n  branchFromContentKey,\n  generateContentKey,\n  contentKeyFromBranch,\n  CMS_BRANCH_PREFIX,\n  statusToLabel,\n  labelToStatus,\n  parseContentKey,\n} from 'decap-cms-lib-util/src/APIUtils';\nimport { parse } from 'what-the-diff';\n// eslint-disable-next-line import/no-named-as-default\nimport simpleGit from 'simple-git';\nimport { Mutex, withTimeout } from 'async-mutex';\n\nimport { defaultSchema, joi } from '../joi';\nimport { pathTraversal } from '../joi/customValidators';\nimport { listRepoFiles, writeFile, move, deleteFile, getUpdateDate } from '../utils/fs';\nimport { entriesFromFiles, readMediaFile } from '../utils/entries';\n\nimport type {\n  EntriesByFolderParams,\n  EntriesByFilesParams,\n  GetEntryParams,\n  DefaultParams,\n  UnpublishedEntryParams,\n  PersistEntryParams,\n  GetMediaParams,\n  Asset,\n  PublishUnpublishedEntryParams,\n  PersistMediaParams,\n  DeleteFileParams,\n  UpdateUnpublishedEntryStatusParams,\n  DataFile,\n  GetMediaFileParams,\n  DeleteEntryParams,\n  DeleteFilesParams,\n  UnpublishedEntryDataFileParams,\n  UnpublishedEntryMediaFileParams,\n} from '../types';\nimport type express from 'express';\nimport type winston from 'winston';\nimport type { SimpleGit } from 'simple-git';\n\nasync function commit(git: SimpleGit, commitMessage: string) {\n  await git.add('.');\n  await git.commit(commitMessage, undefined, {\n    // setting the value to a string passes name=value\n    // any other value passes just the key\n    '--no-verify': null,\n    '--no-gpg-sign': null,\n  });\n}\n\nasync function getCurrentBranch(git: SimpleGit) {\n  const currentBranch = await git.branchLocal().then(summary => summary.current);\n  return currentBranch;\n}\n\nasync function runOnBranch<T>(git: SimpleGit, branch: string, func: () => Promise<T>) {\n  const currentBranch = await getCurrentBranch(git);\n  try {\n    if (currentBranch !== branch) {\n      await git.checkout(branch);\n    }\n    const result = await func();\n    return result;\n  } finally {\n    await git.checkout(currentBranch);\n  }\n}\n\nfunction branchDescription(branch: string) {\n  return `branch.${branch}.description`;\n}\n\ntype GitOptions = {\n  repoPath: string;\n  logger: winston.Logger;\n};\n\nasync function commitEntry(\n  git: SimpleGit,\n  repoPath: string,\n  dataFiles: DataFile[],\n  assets: Asset[],\n  commitMessage: string,\n) {\n  // save entry content\n  await Promise.all(\n    dataFiles.map(dataFile => writeFile(path.join(repoPath, dataFile.path), dataFile.raw)),\n  );\n  // save assets\n  await Promise.all(\n    assets.map(a => writeFile(path.join(repoPath, a.path), Buffer.from(a.content, a.encoding))),\n  );\n  if (dataFiles.every(dataFile => dataFile.newPath)) {\n    dataFiles.forEach(async dataFile => {\n      await move(path.join(repoPath, dataFile.path), path.join(repoPath, dataFile.newPath!));\n    });\n  }\n\n  // commits files\n  await commit(git, commitMessage);\n}\n\nasync function rebase(git: SimpleGit, branch: string) {\n  const gpgSign = await git.raw(['config', 'commit.gpgsign']);\n  try {\n    if (gpgSign === 'true') {\n      await git.addConfig('commit.gpgsign', 'false');\n    }\n    await git.rebase([branch, '--no-verify']);\n  } finally {\n    if (gpgSign === 'true') {\n      await git.addConfig('commit.gpgsign', gpgSign);\n    }\n  }\n}\n\nasync function merge(git: SimpleGit, from: string, to: string) {\n  const gpgSign = await git.raw(['config', 'commit.gpgsign']);\n  try {\n    if (gpgSign === 'true') {\n      await git.addConfig('commit.gpgsign', 'false');\n    }\n    await git.mergeFromTo(from, to);\n  } finally {\n    if (gpgSign === 'true') {\n      await git.addConfig('commit.gpgsign', gpgSign);\n    }\n  }\n}\n\nasync function isBranchExists(git: SimpleGit, branch: string) {\n  const branchExists = await git.branchLocal().then(({ all }) => all.includes(branch));\n  return branchExists;\n}\n\nasync function getDiffs(git: SimpleGit, source: string, dest: string) {\n  const rawDiff = await git.diff([source, dest]);\n  const diffs = parse(rawDiff).map(d => {\n    const oldPath = d.oldPath?.replace(/b\\//, '') || '';\n    const newPath = d.newPath?.replace(/b\\//, '') || '';\n    const path = newPath || (oldPath as string);\n    return {\n      oldPath,\n      newPath,\n      status: d.status,\n      newFile: d.status === 'added',\n      path,\n      id: path,\n      binary: d.binary || /.svg$/.test(path),\n    };\n  });\n  return diffs;\n}\n\nexport async function validateRepo({ repoPath }: { repoPath: string }) {\n  const git = simpleGit(repoPath);\n  const isRepo = await git.checkIsRepo();\n  if (!isRepo) {\n    throw Error(`${repoPath} is not a valid git repository`);\n  }\n}\n\nexport function getSchema({ repoPath }: { repoPath: string }) {\n  const schema = defaultSchema({ path: pathTraversal(repoPath) });\n  return schema;\n}\n\nexport function localGitMiddleware({ repoPath, logger }: GitOptions) {\n  const git = simpleGit(repoPath);\n\n  // we can only perform a single git operation at any given time\n  const mutex = withTimeout(new Mutex(), 3000, new Error('Request timed out'));\n\n  return async function (req: express.Request, res: express.Response) {\n    let release;\n    try {\n      release = await mutex.acquire();\n      const { body } = req;\n      if (body.action === 'info') {\n        res.json({\n          repo: path.basename(repoPath),\n          publish_modes: ['simple', 'editorial_workflow'],\n          type: 'local_git',\n        });\n        return;\n      }\n      const { branch } = body.params as DefaultParams;\n\n      const branchExists = await isBranchExists(git, branch);\n      if (!branchExists) {\n        const message = `Default branch '${branch}' doesn't exist`;\n        res.status(422).json({ error: message });\n        return;\n      }\n\n      switch (body.action) {\n        case 'entriesByFolder': {\n          const payload = body.params as EntriesByFolderParams;\n          const { folder, extension, depth } = payload;\n          const entries = await runOnBranch(git, branch, () =>\n            listRepoFiles(repoPath, folder, extension, depth).then(files =>\n              entriesFromFiles(\n                repoPath,\n                files.map(file => ({ path: file })),\n              ),\n            ),\n          );\n          res.json(entries);\n          break;\n        }\n        case 'entriesByFiles': {\n          const payload = body.params as EntriesByFilesParams;\n          const entries = await runOnBranch(git, branch, () =>\n            entriesFromFiles(repoPath, payload.files),\n          );\n          res.json(entries);\n          break;\n        }\n        case 'getEntry': {\n          const payload = body.params as GetEntryParams;\n          const [entry] = await runOnBranch(git, branch, () =>\n            entriesFromFiles(repoPath, [{ path: payload.path }]),\n          );\n          res.json(entry);\n          break;\n        }\n        case 'unpublishedEntries': {\n          const cmsBranches = await git\n            .branchLocal()\n            .then(result => result.all.filter(b => b.startsWith(`${CMS_BRANCH_PREFIX}/`)));\n          res.json(cmsBranches.map(contentKeyFromBranch));\n          break;\n        }\n        case 'unpublishedEntry': {\n          let { id, collection, slug, cmsLabelPrefix } = body.params as UnpublishedEntryParams;\n          if (id) {\n            ({ collection, slug } = parseContentKey(id));\n          }\n          const contentKey = generateContentKey(collection as string, slug as string);\n          const cmsBranch = branchFromContentKey(contentKey);\n          const branchExists = await isBranchExists(git, cmsBranch);\n          if (branchExists) {\n            const diffs = await getDiffs(git, branch, cmsBranch);\n            const label = await git.raw(['config', branchDescription(cmsBranch)]);\n            const status = label && labelToStatus(label.trim(), cmsLabelPrefix || '');\n            const updatedAt =\n              diffs.length >= 0\n                ? await runOnBranch(git, cmsBranch, async () => {\n                    const dates = await Promise.all(\n                      diffs.map(({ newPath }) => getUpdateDate(repoPath, newPath)),\n                    );\n                    return dates.reduce((a, b) => {\n                      return a > b ? a : b;\n                    });\n                  })\n                : new Date();\n            const unpublishedEntry = {\n              collection,\n              slug,\n              status,\n              diffs,\n              updatedAt,\n            };\n            res.json(unpublishedEntry);\n          } else {\n            return res.status(404).json({ message: 'Not Found' });\n          }\n          break;\n        }\n        case 'unpublishedEntryDataFile': {\n          const { path, collection, slug } = body.params as UnpublishedEntryDataFileParams;\n          const contentKey = generateContentKey(collection as string, slug as string);\n          const cmsBranch = branchFromContentKey(contentKey);\n          const [entry] = await runOnBranch(git, cmsBranch, () =>\n            entriesFromFiles(repoPath, [{ path }]),\n          );\n          res.json({ data: entry.data });\n          break;\n        }\n        case 'unpublishedEntryMediaFile': {\n          const { path, collection, slug } = body.params as UnpublishedEntryMediaFileParams;\n          const contentKey = generateContentKey(collection as string, slug as string);\n          const cmsBranch = branchFromContentKey(contentKey);\n          const file = await runOnBranch(git, cmsBranch, () => readMediaFile(repoPath, path));\n          res.json(file);\n          break;\n        }\n        case 'deleteUnpublishedEntry': {\n          const { collection, slug } = body.params as DeleteEntryParams;\n          const contentKey = generateContentKey(collection, slug);\n          const cmsBranch = branchFromContentKey(contentKey);\n          const currentBranch = await getCurrentBranch(git);\n          if (currentBranch === cmsBranch) {\n            await git.checkoutLocalBranch(branch);\n          }\n          await git.branch(['-D', cmsBranch]);\n          res.json({ message: `deleted branch: ${cmsBranch}` });\n          break;\n        }\n        case 'persistEntry': {\n          const {\n            cmsLabelPrefix,\n            entry,\n            dataFiles = [entry as DataFile],\n            assets,\n            options,\n          } = body.params as PersistEntryParams;\n\n          if (!options.useWorkflow) {\n            await runOnBranch(git, branch, async () => {\n              await commitEntry(git, repoPath, dataFiles, assets, options.commitMessage);\n            });\n          } else {\n            const slug = dataFiles[0].slug;\n            const collection = options.collectionName as string;\n            const contentKey = generateContentKey(collection, slug);\n            const cmsBranch = branchFromContentKey(contentKey);\n            await runOnBranch(git, branch, async () => {\n              const branchExists = await isBranchExists(git, cmsBranch);\n              if (branchExists) {\n                await git.checkout(cmsBranch);\n              } else {\n                await git.checkoutLocalBranch(cmsBranch);\n              }\n              await rebase(git, branch);\n              const diffs = await getDiffs(git, branch, cmsBranch);\n              // delete media files that have been removed from the entry\n              const toDelete = diffs.filter(\n                d => d.binary && !assets.map(a => a.path).includes(d.path),\n              );\n              await Promise.all(toDelete.map(f => fs.unlink(path.join(repoPath, f.path))));\n              await commitEntry(git, repoPath, dataFiles, assets, options.commitMessage);\n\n              // add status for new entries\n              if (!branchExists) {\n                const description = statusToLabel(options.status, cmsLabelPrefix || '');\n                await git.addConfig(branchDescription(cmsBranch), description);\n              }\n            });\n          }\n          res.json({ message: 'entry persisted' });\n          break;\n        }\n        case 'updateUnpublishedEntryStatus': {\n          const { collection, slug, newStatus, cmsLabelPrefix } =\n            body.params as UpdateUnpublishedEntryStatusParams;\n          const contentKey = generateContentKey(collection, slug);\n          const cmsBranch = branchFromContentKey(contentKey);\n          const description = statusToLabel(newStatus, cmsLabelPrefix || '');\n          await git.addConfig(branchDescription(cmsBranch), description);\n          res.json({ message: `${branch} description was updated to ${description}` });\n          break;\n        }\n        case 'publishUnpublishedEntry': {\n          const { collection, slug } = body.params as PublishUnpublishedEntryParams;\n          const contentKey = generateContentKey(collection, slug);\n          const cmsBranch = branchFromContentKey(contentKey);\n          await merge(git, cmsBranch, branch);\n          await git.deleteLocalBranch(cmsBranch);\n          res.json({ message: `branch ${cmsBranch} merged to ${branch}` });\n          break;\n        }\n        case 'getMedia': {\n          const { mediaFolder } = body.params as GetMediaParams;\n          const mediaFiles = await runOnBranch(git, branch, async () => {\n            const files = await listRepoFiles(repoPath, mediaFolder, '', 1);\n            const serializedFiles = await Promise.all(\n              files.map(file => readMediaFile(repoPath, file)),\n            );\n            return serializedFiles;\n          });\n          res.json(mediaFiles);\n          break;\n        }\n        case 'getMediaFile': {\n          const { path } = body.params as GetMediaFileParams;\n          const mediaFile = await runOnBranch(git, branch, () => {\n            return readMediaFile(repoPath, path);\n          });\n          res.json(mediaFile);\n          break;\n        }\n        case 'persistMedia': {\n          const {\n            asset,\n            options: { commitMessage },\n          } = body.params as PersistMediaParams;\n\n          const file = await runOnBranch(git, branch, async () => {\n            await writeFile(\n              path.join(repoPath, asset.path),\n              Buffer.from(asset.content, asset.encoding),\n            );\n            await commit(git, commitMessage);\n            return readMediaFile(repoPath, asset.path);\n          });\n          res.json(file);\n          break;\n        }\n        case 'deleteFile': {\n          const {\n            path: filePath,\n            options: { commitMessage },\n          } = body.params as DeleteFileParams;\n          await runOnBranch(git, branch, async () => {\n            await deleteFile(repoPath, filePath);\n            await commit(git, commitMessage);\n          });\n          res.json({ message: `deleted file ${filePath}` });\n          break;\n        }\n        case 'deleteFiles': {\n          const {\n            paths,\n            options: { commitMessage },\n          } = body.params as DeleteFilesParams;\n          await runOnBranch(git, branch, async () => {\n            await Promise.all(paths.map(filePath => deleteFile(repoPath, filePath)));\n            await commit(git, commitMessage);\n          });\n          res.json({ message: `deleted files ${paths.join(', ')}` });\n          break;\n        }\n        case 'getDeployPreview': {\n          res.json(null);\n          break;\n        }\n        default: {\n          const message = `Unknown action ${body.action}`;\n          res.status(422).json({ error: message });\n          break;\n        }\n      }\n    } catch (e) {\n      logger.error(\n        `Error handling ${JSON.stringify(req.body)}: ${\n          e instanceof Error ? e.message : 'Unknown error'\n        }`,\n      );\n      res.status(500).json({ error: 'Unknown error' });\n    } finally {\n      release && release();\n    }\n  };\n}\n\ntype Options = {\n  logger: winston.Logger;\n};\n\nexport async function registerMiddleware(app: express.Express, options: Options) {\n  const { logger } = options;\n  const repoPath = path.resolve(process.env.GIT_REPO_DIRECTORY || process.cwd());\n  await validateRepo({ repoPath });\n  app.post('/api/v1', joi(getSchema({ repoPath })));\n  app.post('/api/v1', localGitMiddleware({ repoPath, logger }));\n  logger.info(`Decap CMS Git Proxy Server configured with ${repoPath}`);\n}\n","import crypto from 'crypto';\nimport path from 'path';\nimport { promises as fs } from 'fs';\n\nfunction sha256(buffer: Buffer) {\n  return crypto.createHash('sha256').update(buffer).digest('hex');\n}\n\n// normalize windows os path format\nfunction normalizePath(path: string) {\n  return path.replace(/\\\\/g, '/');\n}\n\nexport async function entriesFromFiles(\n  repoPath: string,\n  files: { path: string; label?: string }[],\n) {\n  return Promise.all(\n    files.map(async file => {\n      try {\n        const content = await fs.readFile(path.join(repoPath, file.path));\n        return {\n          data: content.toString(),\n          file: { path: normalizePath(file.path), label: file.label, id: sha256(content) },\n        };\n      } catch (e) {\n        return {\n          data: null,\n          file: { path: normalizePath(file.path), label: file.label, id: null },\n        };\n      }\n    }),\n  );\n}\n\nexport async function readMediaFile(repoPath: string, file: string) {\n  const encoding = 'base64';\n  const buffer = await fs.readFile(path.join(repoPath, file));\n  const id = sha256(buffer);\n\n  return {\n    id,\n    content: buffer.toString(encoding),\n    encoding,\n    path: normalizePath(file),\n    name: path.basename(file),\n  };\n}\n","import path from 'path';\nimport { promises as fs } from 'fs';\n\nasync function listFiles(dir: string, extension: string, depth: number): Promise<string[]> {\n  if (depth <= 0) {\n    return [];\n  }\n\n  try {\n    const dirents = await fs.readdir(dir, { withFileTypes: true });\n    const files = await Promise.all(\n      dirents.map(dirent => {\n        const res = path.join(dir, dirent.name);\n        return dirent.isDirectory()\n          ? listFiles(res, extension, depth - 1)\n          : [res].filter(f => f.endsWith(extension));\n      }),\n    );\n    return ([] as string[]).concat(...files);\n  } catch (e) {\n    return [];\n  }\n}\n\nexport async function listRepoFiles(\n  repoPath: string,\n  folder: string,\n  extension: string,\n  depth: number,\n) {\n  const files = await listFiles(path.join(repoPath, folder), extension, depth);\n  return files.map(f => f.slice(repoPath.length + 1));\n}\n\nexport async function writeFile(filePath: string, content: Buffer | string) {\n  await fs.mkdir(path.dirname(filePath), { recursive: true });\n  await fs.writeFile(filePath, content);\n}\n\nexport async function deleteFile(repoPath: string, filePath: string) {\n  await fs.unlink(path.join(repoPath, filePath)).catch(() => undefined);\n}\n\nasync function moveFile(from: string, to: string) {\n  await fs.mkdir(path.dirname(to), { recursive: true });\n  await fs.rename(from, to);\n}\n\nexport async function move(from: string, to: string) {\n  // move file\n  await moveFile(from, to);\n\n  // move children\n  const sourceDir = path.dirname(from);\n  const destDir = path.dirname(to);\n  const allFiles = await listFiles(sourceDir, '', 100);\n  await Promise.all(allFiles.map(file => moveFile(file, file.replace(sourceDir, destDir))));\n}\n\nexport async function getUpdateDate(repoPath: string, filePath: string) {\n  return fs\n    .stat(path.join(repoPath, filePath))\n    .then(stat => stat.mtime)\n    .catch(() => new Date());\n}\n","module.exports = require(\"@hapi/joi\");","module.exports = require(\"async-mutex\");","module.exports = require(\"cors\");","module.exports = require(\"dotenv\");","module.exports = require(\"express\");","module.exports = require(\"morgan\");","module.exports = require(\"simple-git\");","module.exports = require(\"what-the-diff\");","module.exports = require(\"winston\");","module.exports = require(\"crypto\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(920);\n"],"names":["CMS_BRANCH_PREFIX","DEFAULT_PR_BODY","MERGE_COMMIT_MESSAGE","getLabelPrefix","labelPrefix","label","startsWith","slice","length","status","collectionName","slug","contentKey","index","indexOf","collection","branch","app","port","process","env","PORT","level","LOG_LEVEL","logger","createLogger","options","registerCommonMiddlewares","mode","MODE","Error","e","error","message","exit","listen","info","combine","colorize","simple","format","transports","Console","stream","write","debug","String","trim","use","json","limit","repoPath","extend","type","base","string","required","messages","validate","value","helpers","join","errors","path","allowedActions","requiredString","requiredNumber","number","requiredBool","bool","defaultParams","object","asset","content","encoding","valid","dataFile","raw","newPath","optional","params","when","switch","is","then","allow","keys","folder","extension","depth","files","array","items","id","cmsLabelPrefix","entry","dataFiles","assets","commitMessage","useWorkflow","xor","newStatus","mediaFolder","paths","min","otherwise","forbidden","action","schema","req","res","next","body","allowUnknown","details","map","i","localFsMiddleware","async","repo","basename","publish_modes","payload","entries","listRepoFiles","entriesFromFiles","file","Promise","all","writeFile","a","Buffer","from","every","forEach","move","mediaFiles","readMediaFile","mediaFile","filePath","deleteFile","JSON","stringify","getSchema","defaultSchema","pathTraversal","resolve","GIT_REPO_DIRECTORY","cwd","post","joi","commit","git","add","undefined","getCurrentBranch","branchLocal","summary","current","runOnBranch","func","currentBranch","checkout","branchDescription","commitEntry","isBranchExists","includes","getDiffs","source","dest","rawDiff","diff","parse","d","oldPath","replace","newFile","binary","test","validateRepo","checkIsRepo","localGitMiddleware","mutex","withTimeout","Mutex","release","acquire","cmsBranches","result","filter","b","contentKeyFromBranch","parseContentKey","generateContentKey","cmsBranch","branchFromContentKey","diffs","labelToStatus","updatedAt","getUpdateDate","reduce","Date","unpublishedEntry","data","checkoutLocalBranch","branchExists","gpgSign","addConfig","rebase","toDelete","f","unlink","description","statusToLabel","to","mergeFromTo","merge","deleteLocalBranch","sha256","buffer","createHash","update","digest","normalizePath","readFile","toString","name","listFiles","dir","dirents","readdir","withFileTypes","dirent","isDirectory","endsWith","concat","moveFile","mkdir","dirname","recursive","rename","catch","sourceDir","destDir","allFiles","stat","mtime","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}